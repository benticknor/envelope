<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Bridge Loading</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.4/css/bulma.min.css">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Nunito:400,700);
      .main {
        padding: 10px;
      }
      [v-cloak] {
        display: none;
      }
      .input {
        width: 80px;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <div class="main" v-cloak>
        <span class="title is-4">Spans</span>
        <div class="field">
          <div class="control">
            <input class="input" v-model.number.lazy="span1" v-on:change="analyze">
            <input class="input" v-model.number.lazy="span2" v-on:change="analyze">
            <input class="input" v-model.number.lazy="span3" v-on:change="analyze">
            <input class="input" v-model.number.lazy="span4" v-on:change="analyze">
            <input class="input" v-model.number.lazy="span5" v-on:change="analyze">
            <input class="input" v-model.number.lazy="span6" v-on:change="analyze">
            <input class="input" v-model.number.lazy="span7" v-on:change="analyze">
            <input class="input" v-model.number.lazy="span8" v-on:change="analyze">
            <input class="input" v-model.number.lazy="span9" v-on:change="analyze">
            <input class="input" v-model.number.lazy="span10" v-on:change="analyze">
          </div>
        </div>
        <span class="title is-4">Report</span>
        <div>
          <table class="table">
            <tbody>
              <tr>
                <th>Joint</th>
                <th>Shear Max</th>
                <th>Shear Min</th>
                <th>Moment Max</th>
                <th>Moment Min</th>
               </tr>
              <tr v-for="(joint, index) in joints">
                <td>{{ joint }}</td>
                <td>{{shearMax[index]}}</td>
                <td>{{shearMin[index]}}</td>
                <td>{{momentMax[index]}}</td>
                <td>{{momentMin[index]}}</td>
              </tr>
            </tbody>
          </table>
          <table class="table">
            <tbody>
              <tr>
                <th>Supports</th>
                <th>Support Max</th>
                <th>Support Min</th>
               </tr>
              <tr v-for="(support, index) in supports">
                <td>{{ support }}</td>
                <td>{{supportMax[index]}}</td>
                <td>{{supportMin[index]}}</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div><!--main-->
    </div><!--app-->
  <script src="https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.min.js"></script>
  <script>
    var app = new Vue({
      el: '#app',
      data: {
        span1: 17.1,
        span2: 20.5,
        span3: 17.1,
        span4: 0,
        span5: 0,
        span6: 0,
        span7: 0,
        span8: 0,
        span9: 0,
        span10: 0,
        divisions: 10,
        shearMax: [],
        shearMin: [],
        momentMax: [],
        momentMin: [],
        supportMax: [],
        supportMin: []
      },
      mounted: function () {
        this.analyze();
      },
      computed: {
        spans: function () {
          var spans = [this.span1, this.span2, this.span3, this.span4, this.span5, this.span6, this.span7, this.span8, this.span9, this.span10];
          return spans.filter(Number);
        },
        supportDistances: function () {
          var cumulative = 0;
          var supportDistances = this.spans.map(function (value) {
            cumulative = Number(cumulative) + Number(value);
            return cumulative;
          });
          supportDistances.unshift(0);
          return supportDistances;
        },
        joints: function () {
          var spans = this.spans;
          var divisions = this.divisions;
          var supportDistances = this.supportDistances;
          var decimalPlaces = _.max(this.spans.map(function (value) {
            if (value.toString().split('.')[1] !== undefined) {
              return value.toString().split('.')[1].length;
            } else {
              return 2;
            }
          }));
          var joints = _.flatten(this.spans.map(function (span, spanIndex) {
            return Array(divisions + 1).fill(0).map(function (val, index) {
              return supportDistances[spanIndex] + span/divisions * index;
            });
          }));
          joints = joints.map(function (value) {
            return Math.round(value * Math.pow(10, decimalPlaces)) / Math.pow(10, decimalPlaces);
          });
          return joints;
        },
        supports: function () {
          return this.supportDistances.map(function (value, index) {return index + 1;});
        }
      },
      methods: {
        analyze: function () {
          var spans = this.spans;
          
          //create placeholder for parameters
          var params = {};
          params.axles = [];
          params.axleLoads = [];
          params.axleSpacing = [];
          // params.UDLs = [];
          params.position = 0;
          params.shearMax = this.joints.map(() => -1000000);
          params.shearMin = this.joints.map(() => 1000000);
          params.momentMax = this.joints.map(() => -1000000);
          params.momentMin = this.joints.map(() => 1000000);
          params.supportMax = this.supports.map(() => -1000000);
          params.supportMin = this.supports.map(() => 1000000);
          
          //analyze each vehicle configuration
          
          //axles 1-5 with 1.25 DLA
          params.axleSpacing = [3.6, 1.2, 6.6, 6.6]
          params.axleLoads = [62.5, 175, 175, 218.75, 150];
          params.axles = this.spacingToDistance(params);
          this.analyzeVehicleGroup(params)
          
          //axles 1-4 with 1.25 DLA
          params.axleSpacing = [3.6, 1.2, 6.6];
          params.axleLoads = [62.5, 175, 175, 218.75];
          params.axles = this.spacingToDistance(params);
          this.analyzeVehicleGroup(params)
          
          //axles 2-5 with 1.25 DLA
          params.axleSpacing = [1.2, 6.6, 6.6];
          params.axleLoads = [175, 175, 218.75, 150];
          params.axles = this.spacingToDistance(params);
          this.analyzeVehicleGroup(params)
          
          //axles 1-3 with 1.3 DLA
          params.axleSpacing = [3.6, 1.2];
          params.axleLoads = [65, 182, 182];
          params.axles = this.spacingToDistance(params);
          this.analyzeVehicleGroup(params)
          
          //axles 3-4 with 1.3 DLA
          params.axleSpacing = [6.6];
          params.axleLoads = [182, 227.5];
          params.axles = this.spacingToDistance(params);
          this.analyzeVehicleGroup(params)
          
          //axle 4 with 1.4 DLA
          params.axles= [0];
          params.axleLoads = [245];
          this.analyzeVehicleGroup(params)
          
          this.shearMax = params.shearMax.map(function (value) {return (Math.round(value * 100) / 100);});
          this.shearMin = params.shearMin.map(function (value) {return (Math.round(value * 100) / 100);});
          this.momentMax = params.momentMax.map(function (value) {return (Math.round(value * 100) / 100);});
          this.momentMin = params.momentMin.map(function (value) {return (Math.round(value * 100) / 100);});
          this.supportMax = params.supportMax.map(function (value) {return (Math.round(value * 100) / 100);});
          this.supportMin = params.supportMin.map(function (value) {return (Math.round(value * 100) / 100);});
        },
        analyzeReactions: function(params) {
          // var UDLs = params.UDLs;
          var axles = params.axles;
          var axleLoads = params.axleLoads;
          
          var spansExpanded = Array(this.spans.length * 2).fill(0);
          var UDLsExpanded = Array(this.spans.length * 2).fill(0);
          this.spans.forEach((value, index) => {
            spansExpanded[index * 2] = value;
            spansExpanded[index * 2 + 1] = value;
            // UDLsExpanded[index * 2] = UDLs[index];
            // UDLsExpanded[index * 2 + 1] = UDLs[index];
          });
          
          var fixedEndMoments = Array(this.spans.length * 2).fill(0);;
          //add moments from UDLs
          // spansExpanded.forEach((value, index) => {
          //   if (index % 2 === 0) {
          //     //index is even
          //     fixedEndMoments[index] = -UDLsExpanded[index] * Math.pow(spansExpanded[index], 2) /12;
          //   } else {
          //     //index is odd
          //     fixedEndMoments[index] = UDLsExpanded[index] * Math.pow(spansExpanded[index], 2) / 12;
          //   }
          // });
          //add moments from axles
          axles.forEach((axle, index) => {
            var axleDistance = params.position - axle;
            var spanIndex = this.supportDistances.findIndex((distance) => {
              return distance > axleDistance;
            }) - 1;
            if (axleDistance >= 0) {
              var a = params.position - axle - this.supportDistances[spanIndex];
              var b = this.spans[spanIndex] - a;
              fixedEndMoments[spanIndex * 2] -= axleLoads[index] * b * b * a / Math.pow(this.spans[spanIndex], 2);
              fixedEndMoments[spanIndex * 2 + 1] += axleLoads[index] * a * a * b / Math.pow(this.spans[spanIndex], 2);
            }
          });
          
          var distributionFactors = spansExpanded.map((value, index) => {
            if (index === 0 || index === spansExpanded.length - 1) {
              //end support
              return 0;
            } else {
              if (index % 2 === 0) {
                //index is even
                return spansExpanded[index - 1]/(Number(spansExpanded[index]) + Number(spansExpanded[index - 1]));
              } else {
                //index is odd
                return spansExpanded[index + 1]/(Number(spansExpanded[index]) + Number(spansExpanded[index + 1]));
              }
            }
          });
          var table = [];
          table[0] = Object.assign([], fixedEndMoments);
          for (let i = 1; i < 200; i++) {
            //release
            table[i] = [];
            distributionFactors.forEach((value, index) => {
              if (index == 0 || index == distributionFactors.length - 1) {
                table[i][index] = -table[i - 1][index];
              } else if (index % 2 === 0) {
                //index is even
                table[i][index] = -(table[i - 1][index] + table[i - 1][Number(index) - 1]) * value;
              } else {
                //index is odd
                table[i][index] = -(table[i - 1][index] + table[i - 1][Number(index) + 1]) * value;
              }
            });
            //carryover
            i++;
            table[i] = [];
            distributionFactors.forEach((value, index) => {
              if (index % 2 === 0) {
                //index is even
                table[i][index] = 0.5 * table[i - 1][Number(index) + 1];
              } else {
                //index is odd
                table[i][index] = 0.5 * table[i - 1][Number(index) - 1];
              }
            });
          }//for i
          var sum = (r, a) => r.map((b, i) => a[i] + b);
          var internalMoments = table.reduce(sum);
          var internalReactions = internalMoments.map((value, index) => {
            if (index % 2 === 0) {
              //index is even
              return -1 * (value + internalMoments[index + 1]) / spansExpanded[index];
            } else {
              //index is odd
              return (value + internalMoments[index - 1]) / spansExpanded[index];
            }
          });
          //add reactions from UDLs
          var externalReactions = Array(this.spans.length * 2).fill(0);
          // var externalReactions = spansExpanded.map((value, index) => value * UDLsExpanded[index]/2);
          //add reactions from axles
          axles.forEach((axle, index) => {
            var axleDistance = params.position - axle;
            var spanIndex = this.supportDistances.findIndex((distance) => {
              return distance > axleDistance;
            }) - 1;
            if (axleDistance >= 0) {
              var a = params.position - axle - this.supportDistances[spanIndex];
              var b = this.spans[spanIndex] - a;
              externalReactions[spanIndex * 2] += axleLoads[index] * b / this.spans[spanIndex];
              externalReactions[spanIndex * 2 + 1] += axleLoads[index] * a /this.spans[spanIndex];
            }
          });
          var reactionsExpanded = internalReactions.map((value, index) => value + externalReactions[index]);
          
          return reactionsExpanded;
        },
        analyzeVehicleGroup: function (params) {
          var numberOfIncrements = Math.max(Math.round(_.sum(this.spans)) * 2, 1000);
          var increment = (_.sum(this.spans) + _.max(params.axles)) / (numberOfIncrements - 1);
          
          for (let i = 0; i < numberOfIncrements; i++) {
            params.position = i * increment;
            this.analyzeVehicle(params);
          }
          
          if(params.axles.length === 1) {
            //exit the function (a single axle can't be reversed)
            return;
          }
          
          params.axleSpacing = _.reverse(params.axleSpacing)
          params.axleLoads = _.reverse(params.axleLoads)
          params.axles = this.spacingToDistance(params);
          
          for (let i = 0; i < numberOfIncrements; i++) {
            params.position = i * increment;
            this.analyzeVehicle(params);
          }
        },
        analyzeVehicle: function (params) {
          var UDLs = params.UDLs;
          var axles = params.axles;
          var axleLoads = params.axleLoads;
          
          var reactions = this.analyzeReactions(params);
          var supportReactions = this.analyzeSupportReactions(reactions);
          
          var shear = _.flatten(this.spans.map((spanValue, spanIndex) => {
            return Array(this.divisions + 1).fill(0).map((divValue, divIndex) => {
              var result = 0;
              //add shear from reactions
              supportReactions.forEach((reactionValue, reactionIndex) => {
                if (reactionIndex <= spanIndex) {
                  result += reactionValue;
                }
              });
              //subtract shear from UDLs
              // UDLs.forEach((UDLValue, UDLIndex) => {
              //   if (UDLIndex < spanIndex) {
              //     result -= this.spans[UDLIndex] * UDLValue;
              //   }
              // });
              // result -= (UDLs[spanIndex] * spanValue / this.divisions * divIndex);
              //subtract shear from axles
              axles.forEach((axleValue, axleIndex) => {
                var axleDistance = params.position - axleValue;
                var divStart = this.supportDistances[spanIndex] + spanValue / this.divisions * divIndex;
                if (axleDistance <= divStart && axleDistance >= 0) {
                  result -= axleLoads[axleIndex];
                }
              });
              return result;
            });
          }));
          
          var moment = _.flatten(this.spans.map((spanValue, spanIndex) => {
            return Array(this.divisions + 1).fill(0).map((divValue, divIndex) => {
              var result = 0;
              var divStart = this.supportDistances[spanIndex] + spanValue / this.divisions * divIndex;
              //add moments from reactions
              supportReactions.forEach((reactionValue, reactionIndex) => {
                if (reactionIndex <= spanIndex) {
                  result += reactionValue * (divStart - this.supportDistances[reactionIndex]);
                }
              });
              //subtract moments from UDLs
              // UDLs.forEach((UDLValue, UDLIndex) => {
              //   if (UDLIndex < spanIndex) {
              //     result -= this.spans[UDLIndex] * UDLValue *  (divStart - (this.supportDistances[UDLIndex] + this.spans[UDLIndex] / 2));
              //   }
              // });
              //   result -= UDLs[spanIndex] * Math.pow(spanValue / this.divisions * divIndex, 2) / 2;
              //subtract moment from axles
              axles.forEach((axleValue, axleIndex) => {
                var axleDistance = params.position - axleValue;
                if (axleDistance <= divStart && axleDistance >= 0) {
                  result -= axleLoads[axleIndex] * (divStart - axleDistance);
                }
              });
              return result;
            });
          }));

          params.shearMax = params.shearMax.map((value, index) => Math.max(value, shear[index]));
          params.shearMin = params.shearMin.map((value, index) => Math.min(value, shear[index]));
          params.momentMax = params.momentMax.map((value, index) => Math.max(value, moment[index]));
          params.momentMin = params.momentMin.map((value, index) => Math.min(value, moment[index]));
          params.supportMax = params.supportMax.map((value, index) => Math.max(value, supportReactions[index]));
          params.supportMin = params.supportMin.map((value, index) => Math.min(value, supportReactions[index]));
        },
        spacingToDistance: function (params) {
          var cumulative = 0;
          var axles = params.axleSpacing.map(function (value) {
            cumulative = Number(cumulative) + Number(value);
            return cumulative;
          });
          axles.unshift(0);
          return axles;
        },
        analyzeSupportReactions: function(reactionsExpanded) {
          var supportReactions = [];
          var index = 0;
           this.supports.forEach(() => {
            if (index === 0 || index === reactionsExpanded.length - 1) {
              //end support
              supportReactions.push(reactionsExpanded[index]);
              index ++;
            } else {
              //interior support
              supportReactions.push(reactionsExpanded[index] + reactionsExpanded[index + 1]);
              index += 2;
            }
          });
          return supportReactions;
        }
      }
    });
  </script>
  </body>
</html>
