<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Bridge Loading</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.4/css/bulma.min.css">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Nunito:400,700);
      .main {
        padding: 10px;
      }
      [v-cloak] {
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <div class="main" v-cloak>
        <span class="title is-4">Spans</span>
        <div class="field is-grouped is-grouped-multiline">
          <div class="control" v-for="(span, index) in spans">
            <div class="tags has-addons">
              <a class="tag is-link" v-on:click="editSpan(index)">{{ span }}</a>
              <a class="tag is-delete" v-on:click="deleteSpan(index)"></a>
            </div>
          </div>
        </div>
        <div class="buttons">
          <a class="button is-primary" v-on:click="addSpan()">Add Span</a>
        </div>
        <span class="title is-4">Report</span>
        <div v-for="(loadCase, id) in cases">
          <div>{{loadCase.name}}</div>
          <table class="table">
            <tbody>
              <tr>
                <th>Joint</th>
                <th>Shear Max</th>
                <th>Shear Min</th>
                <th>Moment Max</th>
                <th>Moment Min</th>
               </tr>
              <tr v-for="(joint, index) in joints">
                <td>{{ joint }}</td>
                <td>{{loadCase.shearMax[index]}}</td>
                <td>{{loadCase.shearMin[index]}}</td>
                <td>{{loadCase.momentMax[index]}}</td>
                <td>{{loadCase.momentMin[index]}}</td>
              </tr>
            </tbody>
          </table>
          <table class="table">
            <tbody>
              <tr>
                <th>Supports</th>
                <th>Support Max</th>
                <th>Support Min</th>
               </tr>
              <tr v-for="(support, index) in supports">
                <td>{{ support }}</td>
                <td>{{loadCase.supportMax[index]}}</td>
                <td>{{loadCase.supportMin[index]}}</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div><!--main-->
    </div><!--app-->
  <script src="https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.min.js"></script>
  <script>
    var app = new Vue({
      el: '#app',
      data: {
        spans: [ 10 ],
        divisions: [ 10 ],
        cases: {},
        activeCase: "",
        route: "spans",
        type: "All",
        displayDivisions: false,
        loaded: true
      },
      computed: {
        supportDistances: function () {
          var cumulative = 0;
          var supportDistances = this.spans.map(function (value) {
            cumulative = Number(cumulative) + Number(value);
            return cumulative;
          });
          supportDistances.unshift(0);
          return supportDistances;
        },
        joints: function () {
          var spans = this.spans;
          var divisions = this.divisions;
          var supportDistances = this.supportDistances;
          var decimalPlaces = _.max(spans.map(function (value) {
            if (value.toString().split('.')[1] !== undefined) {
              return value.toString().split('.')[1].length;
            } else {
              return 2;
            }
          }));
          var joints = _.uniq(_.flatten(spans.map(function (span, spanIndex) {
            return Array(divisions[spanIndex] + 1).fill(0).map(function (val, index) {
              return supportDistances[spanIndex] + span/divisions[spanIndex] * index;
            });
          })));
          joints = joints.map(function (value) {
            return Math.round(value * Math.pow(10, decimalPlaces)) / Math.pow(10, decimalPlaces);
          });
          return joints;
        },
        supports: function () {
          return this.supportDistances.map(function (value, index) {return index + 1;});
        }
      },
      methods: {
        addSpan: function () {
          var length = prompt("Please enter a span length", "");
          var params = {};
          if (!isNaN(length) && length >= 0 && length !== null) {
            this.spans.push(length);
            this.divisions.push(10);
            for (let id in this.cases) {
              if (this.cases[id].equalizeUDLs) {
                this.cases[id].UDLs.push(this.cases[id].UDLs[0]);
              } else {
                this.cases[id].UDLs.push(0);
              }
              params = this.generateParams(this.cases[id]);
              this.analyzeConfiguration(params);
              this.writeConfig(params, id);
            }
          } else {
            alert("Invalid span length");
          }
        },
        deleteSpan: function (index) {
          var params = {};
          this.spans.splice(index, 1);
          this.divisions.splice(index, 1);
          for (let id in this.cases) {
            this.cases[id].UDLs.splice(index, 1);
            params = this.generateParams(this.cases[id]);
            this.analyzeConfiguration(params);
            this.writeConfig(params, id);
          }
        },
        editSpan: function (index) {
          var length = prompt("Please enter a span length", this.spans[index]);
          var params = {};
          if (!isNaN(length) && length >= 0 && length !== null) {
            this.spans.splice(index, 1, length);
            for (let id in this.cases) {
              params = this.generateParams(this.cases[id]);
              this.analyzeConfiguration(params);
              this.writeConfig(params, id);
            }
          } else {
            alert("Invalid span length");
          }
          var div = prompt("Please enter a number of points", this.divisions[index]);
          if (!isNaN(div) && div >= 0 && div !== null) {
            this.divisions.splice(index, 1, div);
            for (let id in this.cases) {
              params = this.generateParams(this.cases[id]);
              this.analyzeConfiguration(params);
              this.writeConfig(params, id);
            }
          } else {
            alert("Invalid number of points");
          }
        },
        editDivision: function (number, index) {
          var params = {};
          this.divisions.splice(index, 1, number);
          for (let id in this.cases) {
            params = this.generateParams(this.cases[id]);
            this.analyzeConfiguration(params);
            this.writeConfig(params, id);
          }
        },
        addConfiguration: function () {
          var name = prompt("Please enter a configuration name", "");
          var id = Math.random().toString(36).substring(7);
          Vue.set(this.cases, id, {
            name: name,
            type: 'Configuration',
            axles: [],
            axleLoads: [],
            UDLs: this.spans.map(function () {return 0;}),
            equalizeUDLs: false,
            entries: [],
            factors: [],
            shearMax: [],
            shearMin: [],
            momentMax: [],
            momentMin: [],
            bearingMax: [],
            bearingMin: [],
            supportMax: [],
            supportMin: []
          });
          this.activeCase = id;
          var params = this.generateParams(this.cases[id]);
          this.analyzeConfiguration(params);
          this.writeConfig(params, id);
        },
        deleteCase: function (id) {
          Vue.delete(this.cases, id);
        },
        analyzeCases: function () {
          for (let id in this.cases) {
            params = this.generateParams(this.cases[id]);
            this.analyzeConfiguration(params);
            this.writeConfig(params, id);
          }
        },
        generateParams: function(loadCase) {
          var params = {};
          params.spans = Object.assign([], this.spans);
          params.divisions = Object.assign([], this.divisions);
          params.UDLs = Object.assign([], loadCase.UDLs);
          params.equalizeUDLs = false;
          params.axles = Object.assign([], loadCase.axles);
          params.axleLoads = Object.assign([], loadCase.axleLoads);
          params.supportDistances = this.supportDistances;
          params.joints = this.joints;
          params.shearMax = [];
          params.shearMin = [];
          params.momentMax = [];
          params.momentMin = [];
          params.bearingMax = [];
          params.bearingMin = [];
          params.supportMax = [];
          params.supportMin = [];
          return params;
        },
        writeConfig: function(params, id) {
          this.cases[id].shearMax = params.shearMax.map(function (value) {return (Math.round(value * 100) / 100);});
          this.cases[id].shearMin = params.shearMin.map(function (value) {return (Math.round(value * 100) / 100);});
          this.cases[id].momentMax = params.momentMax.map(function (value) {return (Math.round(value * 100) / 100);});
          this.cases[id].momentMin = params.momentMin.map(function (value) {return (Math.round(value * 100) / 100);});
          this.cases[id].supportMax = params.supportMax.map(function (value) {return (Math.round(value * 100) / 100);});
          this.cases[id].supportMin = params.supportMin.map(function (value) {return (Math.round(value * 100) / 100);});
          this.cases[id].bearingMax = params.bearingMax.map(function (value) {return (Math.round(value * 100) / 100);});
          this.cases[id].bearingMin = params.bearingMin.map(function (value) {return (Math.round(value * 100) / 100);});
        },
        analyzeConfiguration: function (params) {
          var spans = params.spans;
          var axles= params.axles;
          var axleLoads = params.axleLoads;
          if (axles.length === 0) {axles=[0]; axleLoads = [0];}
          var numberOfIncrements = Math.max(Math.round(_.sum(spans) + 0) * 2, 100);
          var increment = (_.sum(spans) + _.max(axles)) / (numberOfIncrements - 1);
          var a = 0; // Distance from first support to first vehicle axle
          for (let i = 0; i < numberOfIncrements; i++) {
            a = i * increment;
            this.axleDistances(params, a);
            this.axleSpans(params);
            this.analyzeVehicle(params);
            if (_.sum(axleLoads) === 0) {
              break;
            }
          } // for i
          axles = this.reverseVehicle(axles);
          for (let i = 0; i < numberOfIncrements; i++) {
            a = i * increment;
            this.axleDistances(params, a);
            this.axleSpans(params);
            this.analyzeVehicle(params);
            if (_.sum(axleLoads) === 0) {
              break;
            }
          } // for i
        },
        axleDistances: function (params, a) {
          var spans = params.spans;
          var supportDistances = params.supportDistances;
          var axles= params.axles;
          var axleDistances = {a: [], b: [], c: []};
          for (let i = 0; i < axles.length; i++) {
            axleDistances.a[i] = a - axles[i];
            axleDistances.b[i] = 0;
            axleDistances.c[i] = 0;
            for (let j = 0; j < spans.length; j++) {
              if (axleDistances.a[i] >= supportDistances[j] && axleDistances.a[i] <= supportDistances[j + 1]) {
                axleDistances.b[i] = axleDistances.a[i] - supportDistances[j];
                axleDistances.c[i] = spans[j] - axleDistances.b[i];
              }//if
            }//for j
          }//for i
          params.axleDistances = axleDistances;
        },
        axleSpans: function (params) {
          var spans = params.spans;
          var supportDistances = params.supportDistances;
          var axleDistances = params.axleDistances;
          var axles= params.axles;
          var axleSpans = [0];
          for (let i = 0; i < axles.length; i++) {
            for (let j = 0; j < spans.length; j++) {
              if (axleDistances.a[i] >= supportDistances[j] && axleDistances.a[i] <= supportDistances[j + 1]) {
                axleSpans[i] = j;
              }//if
            }
          }
          params.axleSpans = axleSpans;
        },
        analyzeVehicle: function (params) {
          var joints= params.joints;
          var shear = [];
          var moment = [];
          var shearMax = params.shearMax;
          var shearMin = params.shearMin;
          var momentMax = params.momentMax;
          var momentMin = params.momentMin;
          var bearingMax = params.bearingMax;
          var bearingMin = params.bearingMin;
          var supportMax = params.supportMax;
          var supportMin = params.supportMin;

          params.reactions = this.calculateReactions(params);

          for (let i = 0; i < joints.length; i++) {
            shear[i] = this.calculateShear(params, joints[i], joints[i + 1]);
            moment[i] = this.calculateMoment(params, joints[i], joints[i + 1]);
          }

          for (let i = 0; i < joints.length; i++) {
            //Initialize arrays with an initial value
            if (shearMax[i] === undefined) {
              shearMax[i] = shear[i];
            }
            if (shearMin[i] === undefined) {
              shearMin[i] = shear[i];
            }
            if (momentMax[i] === undefined) {
              momentMax[i] = moment[i];
            }
            if (momentMin[i] === undefined) {
              momentMin[i] = moment[i];
            }

            //Compare shears
            if (shear[i] >= shearMax[i]) {
              shearMax[i] = shear[i];
            }
            if (shear[i] <= shearMin[i]) {
              shearMin[i] = shear[i];
            }

            //Compare moments
            if (moment[i] >= momentMax[i]) {
              momentMax[i] = moment[i];
            }
            if (moment[i] <= momentMin[i]) {
              momentMin[i] = moment[i];
            }

            //Clear shear and moment
            shear[i] = 0;
            moment[i] = 0;
          }//for i

          var supports = this.reduceReactions(params.reactions);

          for (let i = 0; i < supports.length; i++) {
            //Initialize arrays with an initial value
            if (supportMax[i] === undefined) {
              supportMax[i] = supports[i];
              supportMin[i] = supports[i];
            }
            //Compare reactions
            if (supports[i] >= supportMax[i]) {
              supportMax[i] = supports[i];
            }
            if (supports[i] <= supportMin[i]) {
              supportMin[i] = supports[i];
            }

            //Clear reactions
            params.reactions = params.reactions.map(function () {return 0;});
          }//for i
        },
        reverseVehicle: function (axles) {
          var axlesReversed = [];
          var tempArray = [];
          for (let i = 0; i < axles.length; i++) {
            tempArray[i] = _.max(axles) - axles[i];
          }
          for (let i = 0; i < axles.length; i++) {
            axlesReversed[i] = tempArray[i];
          }
          return axlesReversed;
        },
        reduceReactions: function(reactionsExtended) {
          var supportReactions = [];
          var index = 0;
           this.supports.forEach(() => {
            if (index === 0 || index === reactionsExtended.length - 1) {
              //end support
              supportReactions.push(reactionsExtended[index]);
              index ++;
            } else {
              //interior support
              supportReactions.push(reactionsExtended[index] + reactionsExtended[index + 1]);
              index += 2;
            }
          });
          return supportReactions;
        },
        booleansToNumbers: function(booleans) {
          var numbers = [];
          for (var i = 0; i < booleans.length; i++) {
            if (booleans[i]) {
              numbers.push(i + 1);
            }
          }
          return numbers;
        },
        calculateShear: function(params, x, x2) {
          var spans = params.spans;
          var axleDistances = params.axleDistances;
          var supportDistances = params.supportDistances;
          var axles= params.axles;
          var axleLoads= params.axleLoads;
          var UDLs= params.UDLs;
          var reactions = this.reduceReactions(params.reactions);
          var shear = 0;

          if (_.sum(reactions) === 0) {
            //do nothing
          } else if (x === 0) {
            shear = reactions[0];
          } else if (Math.abs(x - _.sum(spans)) < 0.001) {
            shear = -reactions[reactions.length - 1];
          } else {
            //Add reactions up to x
            for (let i = 0; i < spans.length; i++) {
              if (x >= supportDistances[i]) {
                shear = shear + reactions[i];
              }
            }

            //Add shear from axles
            for (let i = 0; i < axles.length; i++) {
              if (x > axleDistances.a[i] && axleDistances.a[i] >= 0) {
                shear = shear - axleLoads[i];
              }
            }

            //Add shear from UDLs
            for (let i = 0; i < spans.length; i++) {
              if (x > supportDistances[i] &&
                  x2 >= supportDistances[i + 1] &&
                  Math.abs(supportDistances[i + 1] - _.sum(spans)) > 0.001) {
                if (UDLs[i] !== undefined) {shear = shear - UDLs[i] * spans[i];}
              } else if (x > supportDistances[i] && x < supportDistances[i + 1]) {
                if (UDLs[i] !== undefined) {shear = shear - UDLs[i] * (x - supportDistances[i]);}
              }
            }
          }

          const decimalPlaces = 2;
          shear = Math.round(shear * Math.pow(10, decimalPlaces)) / Math.pow(10, decimalPlaces);

          return shear;
        },
        calculateMoment: function(params, x, x2) {
          var spans = params.spans;
          var axleDistances = params.axleDistances;
          var supportDistances = params.supportDistances;
          var axles= params.axles;
          var axleLoads= params.axleLoads;
          var UDLs= params.UDLs;
          var reactions = this.reduceReactions(params.reactions);
          var moment = 0;

          if (_.sum(reactions) === 0) {
            //do nothing
          } else if (x === 0) {
            moment = 0;
          } else if (x2 === undefined) {
            moment = 0;
          } else {
            //Add reactions up to x
            for (let i = 0; i < spans.length; i++) {
              if (x >= supportDistances[i]) {
                moment = moment + reactions[i] * (x - supportDistances[i]);
              }
            }

            //Add moment from axles
            for (let i = 0; i < axles.length; i++) {
              if (x > axleDistances.a[i] && axleDistances.a[i] >= 0) {
                moment = moment - axleLoads[i] * (x - axleDistances.a[i]);
              }
            }

            //Add moment from UDLs
            for (let i = 0; i < spans.length; i++) {
              if (x > supportDistances[i] && x >= supportDistances[i + 1]) {
                if (UDLs[i] !== undefined) {moment = moment - UDLs[i] * spans[i] * (x - supportDistances[i] - spans[i] / 2);}
              } else if (x > supportDistances[i] && x < supportDistances[i + 1]) {
                if (UDLs[i] !== undefined) {moment = moment - UDLs[i] * Math.pow(x - supportDistances[i], 2) / 2;}
              }
            }
          }

          const decimalPlaces = 2;
          moment = Math.round(moment * Math.pow(10, decimalPlaces)) / Math.pow(10, decimalPlaces);

          return moment;
        },
        calculateReactions: function(params) {
          var spans = this.spans;
          var UDLs = this.cases[params.id].UDLs;
          var axles = params.axles;
          var axleLoads = params.axleLoads;

          var spansExpanded = Array(spans.length * 2).fill(0);
          var UDLsExpanded = Array(spans.length * 2).fill(0);
          spans.forEach((value, index) => {
            spansExpanded[index * 2] = value;
            spansExpanded[index * 2 + 1] = value;
            UDLsExpanded[index * 2] = UDLs[index];
            UDLsExpanded[index * 2 + 1] = UDLs[index];
          });
          var fixedEndMoments = [];
          //add moments from UDLs
          spansExpanded.forEach((value, index) => {
            if (index % 2 === 0) {
              //index is even
              fixedEndMoments[index] = -UDLsExpanded[index] * Math.pow(spansExpanded[index], 2) /12;
            } else {
              //index is odd
              fixedEndMoments[index] = UDLsExpanded[index] * Math.pow(spansExpanded[index], 2) / 12;
            }
          });
          //add moments from axles
          axles.forEach((axle, index) => {
            var axleDistance = params.position - axle;
            var spanIndex = this.supportDistances.findIndex((distance) => {
              return distance > axleDistance;
            }) - 1;
            if (axleDistance >= 0) {
              var a = params.position - axle - this.supportDistances[spanIndex];
              var b = this.spans[spanIndex] - a;
              fixedEndMoments[spanIndex * 2] -= axleLoads[index] * b * b * a / Math.pow(this.spans[spanIndex], 2);
              fixedEndMoments[spanIndex * 2 + 1] += axleLoads[index] * a * a * b / Math.pow(this.spans[spanIndex], 2);
            }
          });
          var releasesExtended = [];
          var i = 0;
          this.supports.forEach((value, index) => {
            if (index == 0 || index == this.supports.length - 1) {
              releasesExtended[i] = true;
              i++;
            } else {
              releasesExtended[i] = false;
              releasesExtended[i + 1] = false;
              i += 2;
            }
          });
          var distributionFactors = releasesExtended.map((value, index) => {
            if (value) {
              return 0;
            } else {
              if (index % 2 === 0) {
                //index is even
                return spansExpanded[index - 1]/(Number(spansExpanded[index]) + Number(spansExpanded[index - 1]));
              } else {
                //index is odd
                return spansExpanded[index + 1]/(Number(spansExpanded[index]) + Number(spansExpanded[index + 1]));
              }
            }
          });
          var table = [];
          table[0] = Object.assign([], fixedEndMoments);
          for (let i = 1; i < 200; i++) {
            //release
            table[i] = [];
            releasesExtended.forEach((value, index) => {
              if (value === true) {
                table[i][index] = -table[i - 1][index];
              } else if (index % 2 === 0) {
                //index is even
                table[i][index] = -(table[i - 1][index] + table[i - 1][Number(index) - 1]) * distributionFactors[index];
              } else {
                //index is odd
                table[i][index] = -(table[i - 1][index] + table[i - 1][Number(index) + 1]) * distributionFactors[index];
              }
            });
            //carryover
            i++;
            table[i] = [];
            releasesExtended.forEach((value, index) => {
              if (index % 2 === 0) {
                //index is even
                table[i][index] = 0.5 * table[i - 1][Number(index) + 1];
              } else {
                //index is odd
                table[i][index] = 0.5 * table[i - 1][Number(index) - 1];
              }
            });
          }//for i
          var sum = (r, a) => r.map((b, i) => a[i] + b);
          var internalMoments = table.reduce(sum);
          var internalReactions = internalMoments.map((value, index) => {
            if (index % 2 === 0) {
              //index is even
              return -1 * (value + internalMoments[index + 1]) / spansExpanded[index];
            } else {
              //index is odd
              return (value + internalMoments[index - 1]) / spansExpanded[index];
            }
          });
          //add reactions from UDLs
          var externalReactions = spansExpanded.map((value, index) => value * UDLsExpanded[index]/2);
          //add reactions from axles
          axles.forEach((axle, index) => {
            var axleDistance = params.position - axle;
            var spanIndex = this.supportDistances.findIndex((distance) => {
              return distance > axleDistance;
            }) - 1;
            if (axleDistance >= 0) {
              var a = params.position - axle - this.supportDistances[spanIndex];
              var b = this.spans[spanIndex] - a;
              externalReactions[spanIndex * 2] += axleLoads[index] * b / this.spans[spanIndex];
              externalReactions[spanIndex * 2 + 1] += axleLoads[index] * a /this.spans[spanIndex];
            }
          });
          var reactionsExtended = internalReactions.map((value, index) => value + externalReactions[index]);

          return reactionsExtended;
        }
      }
    });
  </script>
  </body>
</html>
