<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Bridge Loading</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.4/css/bulma.min.css">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Nunito:400,700);
      .main {
        padding: 10px;
      }
      [v-cloak] {
        display: none;
      }
      .input {
        width: 80px;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <div class="main" v-cloak>
        <span class="title is-4">Spans</span>
        <div class="field">
          <div class="control">
            <input class="input" v-model.number="span1">
            <input class="input" v-model.number="span2">
            <input class="input" v-model.number="span3">
            <input class="input" v-model.number="span4">
            <input class="input" v-model.number="span5">
            <input class="input" v-model.number="span6">
            <input class="input" v-model.number="span7">
            <input class="input" v-model.number="span8">
            <input class="input" v-model.number="span9">
            <input class="input" v-model.number="span10">
          </div>
        </div>
        <span class="title is-4">Report</span>
        <div>
          <table class="table">
            <tbody>
              <tr>
                <th>Joint</th>
                <th>Shear Max</th>
                <th>Shear Min</th>
                <th>Moment Max</th>
                <th>Moment Min</th>
               </tr>
              <tr v-for="(joint, index) in joints">
                <td>{{ joint }}</td>
                <td>{{shearMax[index]}}</td>
                <td>{{shearMin[index]}}</td>
                <td>{{momentMax[index]}}</td>
                <td>{{momentMin[index]}}</td>
              </tr>
            </tbody>
          </table>
          <table class="table">
            <tbody>
              <tr>
                <th>Supports</th>
                <th>Support Max</th>
                <th>Support Min</th>
               </tr>
              <tr v-for="(support, index) in supports">
                <td>{{ support }}</td>
                <td>{{supportMax[index]}}</td>
                <td>{{supportMin[index]}}</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div><!--main-->
    </div><!--app-->
  <script src="https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.min.js"></script>
  <script>
    var app = new Vue({
      el: '#app',
      data: {
        span1: 10,
        span2: 10,
        span3: 10,
        span4: 0,
        span5: 0,
        span6: 0,
        span7: 0,
        span8: 0,
        span9: 0,
        span10: 0,
        divisions: 10,
        shearMax: [],
        shearMin: [],
        momentMax: [],
        momentMin: [],
        supportMax: [],
        supportMin: []
      },
      computed: {
        spans: function () {
          var spans = [this.span1, this.span2, this.span3, this.span4, this.span5, this.span6, this.span7, this.span8, this.span9, this.span10];
          return spans.filter(Number);
        },
        supportDistances: function () {
          var cumulative = 0;
          var supportDistances = this.spans.map(function (value) {
            cumulative = Number(cumulative) + Number(value);
            return cumulative;
          });
          supportDistances.unshift(0);
          return supportDistances;
        },
        joints: function () {
          var spans = this.spans;
          var divisions = this.divisions;
          var supportDistances = this.supportDistances;
          var decimalPlaces = _.max(spans.map(function (value) {
            if (value.toString().split('.')[1] !== undefined) {
              return value.toString().split('.')[1].length;
            } else {
              return 2;
            }
          }));
          var joints = _.uniq(_.flatten(spans.map(function (span, spanIndex) {
            return Array(divisions + 1).fill(0).map(function (val, index) {
              return supportDistances[spanIndex] + span/divisions * index;
            });
          })));
          joints = joints.map(function (value) {
            return Math.round(value * Math.pow(10, decimalPlaces)) / Math.pow(10, decimalPlaces);
          });
          return joints;
        },
        supports: function () {
          return this.supportDistances.map(function (value, index) {return index + 1;});
        }
      },
      methods: {
        generateParams: function() {
          var params = {};
          params.divisions = Object.assign([], this.divisions);
          params.UDLs = Object.assign([], this.UDLs); //fix
          params.equalizeUDLs = false;
          //params.axles = Object.assign([], this.axles);
          //params.axleLoads = Object.assign([], this.axleLoads);
          params.supportDistances = this.supportDistances;
          params.joints = this.joints;
          params.shearMax = [];
          params.shearMin = [];
          params.momentMax = [];
          params.momentMin = [];
          params.supportMax = [];
          params.supportMin = [];
          return params;
        },
        analyzeConfiguration: function (params) {
          var spans = this.spans;
          var axles= params.axles;
          var axleLoads = params.axleLoads;
          if (axles.length === 0) {
            axles=[0]; axleLoads = [0];
            this.analyzeVehicle(params);
          } else {
            var numberOfIncrements = Math.max(Math.round(_.sum(spans)) * 2, 200);
            var increment = (_.sum(spans) + _.max(axles)) / (numberOfIncrements - 1);
            params.position = 0; //Distance from first support to first vehicle axle
            for (let i = 0; i < numberOfIncrements; i++) {
              params.position = i * increment;
              this.analyzeVehicle(params);
            }
            params.axles = this.reverseAxles(axles);
            params.axleLoads = _.reverse(axleLoads);
            for (let i = 0; i < numberOfIncrements; i++) {
              params.position = i * increment;
              this.analyzeVehicle(params);
            }
          }
          this.shearMax = params.shearMax.map(function (value) {return (Math.round(value * 100) / 100);});
          this.shearMin = params.shearMin.map(function (value) {return (Math.round(value * 100) / 100);});
          this.momentMax = params.momentMax.map(function (value) {return (Math.round(value * 100) / 100);});
          this.momentMin = params.momentMin.map(function (value) {return (Math.round(value * 100) / 100);});
          this.supportMax = params.supportMax.map(function (value) {return (Math.round(value * 100) / 100);});
          this.supportMin = params.supportMin.map(function (value) {return (Math.round(value * 100) / 100);});
        },
        axleDistances: function (params, a) {
          var spans = params.spans;
          var supportDistances = params.supportDistances;
          var axles= params.axles;
          var axleDistances = {a: [], b: [], c: []};
          for (let i = 0; i < axles.length; i++) {
            axleDistances.a[i] = a - axles[i];
            axleDistances.b[i] = 0;
            axleDistances.c[i] = 0;
            for (let j = 0; j < spans.length; j++) {
              if (axleDistances.a[i] >= supportDistances[j] && axleDistances.a[i] <= supportDistances[j + 1]) {
                axleDistances.b[i] = axleDistances.a[i] - supportDistances[j];
                axleDistances.c[i] = spans[j] - axleDistances.b[i];
              }//if
            }//for j
          }//for i
          params.axleDistances = axleDistances;
        },
        axleSpans: function (params) {
          var spans = params.spans;
          var supportDistances = params.supportDistances;
          var axleDistances = params.axleDistances;
          var axles= params.axles;
          var axleSpans = [0];
          for (let i = 0; i < axles.length; i++) {
            for (let j = 0; j < spans.length; j++) {
              if (axleDistances.a[i] >= supportDistances[j] && axleDistances.a[i] <= supportDistances[j + 1]) {
                axleSpans[i] = j;
              }//if
            }
          }
          params.axleSpans = axleSpans;
        },
        analyzeVehicle: function (params) {
          var UDLs = params.UDLs;
          var axles = params.axles;
          var axleLoads = params.axleLoads;

          var reactions = this.analyzeReactions(params);
          var bearingReactions = this.analyzeBearingReactions(reactions, releases);
          var supportReactions = this.analyzeSupportReactions(reactions, releases);

          var shear = _.flatten(this.spans.map((spanValue, spanIndex) => {
            return Array(this.divisions + 1).fill(0).map((divValue, divIndex) => {
              var result = 0;
              //add shear from reactions
              supportReactions.forEach((reactionValue, reactionIndex) => {
                if (reactionIndex <= spanIndex) {
                  result += reactionValue;
                }
              });
              //subtract shear from UDLs
              UDLs.forEach((UDLValue, UDLIndex) => {
                if (UDLIndex < spanIndex) {
                  result -= this.spans[UDLIndex] * UDLValue;
                }
              });
              result -= (UDLs[spanIndex] * spanValue / this.divisions * divIndex);
              //subtract shear from axles
              axles.forEach((axleValue, axleIndex) => {
                var axleDistance = params.position - axleValue;
                var divStart = this.supportDistances[spanIndex] + spanValue / this.divisions * divIndex;
                if (axleDistance <= divStart && axleDistance >= 0) {
                  result -= axleLoads[axleIndex];
                }
              });
              return result;
            });
          }));
          var moment = _.flatten(this.spans.map((spanValue, spanIndex) => {
            return Array(this.divisions + 1).fill(0).map((divValue, divIndex) => {
              var result = 0;
              var divStart = this.supportDistances[spanIndex] + spanValue / this.divisions * divIndex;
              //add moments from reactions
              supportReactions.forEach((reactionValue, reactionIndex) => {
                if (reactionIndex <= spanIndex) {
                  result += reactionValue * (divStart - this.supportDistances[reactionIndex]);
                }
              });
              //subtract moments from UDLs
              UDLs.forEach((UDLValue, UDLIndex) => {
                if (UDLIndex < spanIndex) {
                  result -= this.spans[UDLIndex] * UDLValue *  (divStart - (this.supportDistances[UDLIndex] + this.spans[UDLIndex] / 2));
                }
              });
                result -= UDLs[spanIndex] * Math.pow(spanValue / this.divisions * divIndex, 2) / 2;
              //subtract moment from axles
              axles.forEach((axleValue, axleIndex) => {
                var axleDistance = params.position - axleValue;
                if (axleDistance <= divStart && axleDistance >= 0) {
                  result -= axleLoads[axleIndex] * (divStart - axleDistance);
                }
              });
              return result;
            });
          }));

          params.shearMax = params.shearMax.map((value, index) => Math.max(value, shear[index]));
          params.shearMin = params.shearMin.map((value, index) => Math.min(value, shear[index]));
          params.momentMax = params.momentMax.map((value, index) => Math.max(value, moment[index]));
          params.momentMin = params.momentMin.map((value, index) => Math.min(value, moment[index]));
          params.bearingMax = params.bearingMax.map((value, index) => Math.max(value, bearingReactions[index]));
          params.bearingMin = params.bearingMin.map((value, index) => Math.min(value, bearingReactions[index]));
          params.supportMax = params.supportMax.map((value, index) => Math.max(value, supportReactions[index]));
          params.supportMin = params.supportMin.map((value, index) => Math.min(value, supportReactions[index]));
        },
        reverseVehicle: function (axles) {
          var axlesReversed = [];
          var tempArray = [];
          for (let i = 0; i < axles.length; i++) {
            tempArray[i] = _.max(axles) - axles[i];
          }
          for (let i = 0; i < axles.length; i++) {
            axlesReversed[i] = tempArray[i];
          }
          return axlesReversed;
        },
        analyzeSupportReactions: function(reactionsExtended) {
          var supportReactions = [];
          var index = 0;
           this.supports.forEach(() => {
            if (index === 0 || index === reactionsExtended.length - 1) {
              //end support
              supportReactions.push(reactionsExtended[index]);
              index ++;
            } else {
              //interior support
              supportReactions.push(reactionsExtended[index] + reactionsExtended[index + 1]);
              index += 2;
            }
          });
          return supportReactions;
        },
        calculateShear: function(params, x, x2) {
          var spans = params.spans;
          var axleDistances = params.axleDistances;
          var supportDistances = params.supportDistances;
          var axles= params.axles;
          var axleLoads= params.axleLoads;
          var UDLs= params.UDLs;
          var reactions = this.reduceReactions(params.reactions);
          var shear = 0;

          if (_.sum(reactions) === 0) {
            //do nothing
          } else if (x === 0) {
            shear = reactions[0];
          } else if (Math.abs(x - _.sum(spans)) < 0.001) {
            shear = -reactions[reactions.length - 1];
          } else {
            //Add reactions up to x
            for (let i = 0; i < spans.length; i++) {
              if (x >= supportDistances[i]) {
                shear = shear + reactions[i];
              }
            }

            //Add shear from axles
            for (let i = 0; i < axles.length; i++) {
              if (x > axleDistances.a[i] && axleDistances.a[i] >= 0) {
                shear = shear - axleLoads[i];
              }
            }

            //Add shear from UDLs
            for (let i = 0; i < spans.length; i++) {
              if (x > supportDistances[i] &&
                  x2 >= supportDistances[i + 1] &&
                  Math.abs(supportDistances[i + 1] - _.sum(spans)) > 0.001) {
                if (UDLs[i] !== undefined) {shear = shear - UDLs[i] * spans[i];}
              } else if (x > supportDistances[i] && x < supportDistances[i + 1]) {
                if (UDLs[i] !== undefined) {shear = shear - UDLs[i] * (x - supportDistances[i]);}
              }
            }
          }

          const decimalPlaces = 2;
          shear = Math.round(shear * Math.pow(10, decimalPlaces)) / Math.pow(10, decimalPlaces);

          return shear;
        },
        calculateMoment: function(params, x, x2) {
          var spans = params.spans;
          var axleDistances = params.axleDistances;
          var supportDistances = params.supportDistances;
          var axles= params.axles;
          var axleLoads= params.axleLoads;
          var UDLs= params.UDLs;
          var reactions = this.reduceReactions(params.reactions);
          var moment = 0;

          if (_.sum(reactions) === 0) {
            //do nothing
          } else if (x === 0) {
            moment = 0;
          } else if (x2 === undefined) {
            moment = 0;
          } else {
            //Add reactions up to x
            for (let i = 0; i < spans.length; i++) {
              if (x >= supportDistances[i]) {
                moment = moment + reactions[i] * (x - supportDistances[i]);
              }
            }

            //Add moment from axles
            for (let i = 0; i < axles.length; i++) {
              if (x > axleDistances.a[i] && axleDistances.a[i] >= 0) {
                moment = moment - axleLoads[i] * (x - axleDistances.a[i]);
              }
            }

            //Add moment from UDLs
            for (let i = 0; i < spans.length; i++) {
              if (x > supportDistances[i] && x >= supportDistances[i + 1]) {
                if (UDLs[i] !== undefined) {moment = moment - UDLs[i] * spans[i] * (x - supportDistances[i] - spans[i] / 2);}
              } else if (x > supportDistances[i] && x < supportDistances[i + 1]) {
                if (UDLs[i] !== undefined) {moment = moment - UDLs[i] * Math.pow(x - supportDistances[i], 2) / 2;}
              }
            }
          }

          const decimalPlaces = 2;
          moment = Math.round(moment * Math.pow(10, decimalPlaces)) / Math.pow(10, decimalPlaces);

          return moment;
        }
      }
    });
  </script>
  </body>
</html>
